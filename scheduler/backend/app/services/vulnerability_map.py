"""
Vulnerability map — student × weekday risk matrix.

For each student with care needs, check each weekday:
  - Is assigned staff qualified? → green
  - Assigned staff qualified but SPOF? → yellow
  - No assigned staff / unqualified? → red
  - No one in entire staff pool can cover? → black
"""

from uuid import UUID
from sqlalchemy.orm import Session

from app.models import Student, Staff, StudentDay, StaffShift
from app.models.staff import StaffRole


def compute_vulnerability_map(
    db: Session,
    week_schedule_id: UUID,
) -> dict:
    """Build a risk matrix: students (rows) × weekdays (columns)."""
    students_with_care = (
        db.query(Student)
        .filter(Student.active == True, Student.has_care_needs == True)  # noqa: E712
        .all()
    )

    if not students_with_care:
        return {"students": [], "summary": {"black": 0, "red": 0, "yellow": 0, "green": 0}}

    active_staff = (
        db.query(Staff)
        .filter(Staff.active == True)  # noqa: E712
        .all()
    )

    # cert → list of staff_ids (globally qualified)
    cert_staff_map: dict[str, list[str]] = {}
    for staff in active_staff:
        for cert in (staff.care_certifications or []):
            cert_staff_map.setdefault(cert, []).append(str(staff.id))

    # Load all student days and staff shifts for this week
    all_student_days = (
        db.query(StudentDay)
        .filter(StudentDay.week_schedule_id == week_schedule_id)
        .all()
    )
    sd_map: dict[tuple, StudentDay] = {}
    for sd in all_student_days:
        sd_map[(str(sd.student_id), sd.weekday)] = sd

    all_shifts = (
        db.query(StaffShift)
        .filter(StaffShift.week_schedule_id == week_schedule_id)
        .all()
    )
    # weekday → set of staff_ids working that day
    day_staff: dict[int, set] = {}
    for ss in all_shifts:
        day_staff.setdefault(ss.weekday, set()).add(str(ss.staff_id))

    # Build staff lookup for cert checking
    staff_by_id: dict[str, Staff] = {str(s.id): s for s in active_staff}

    rows = []
    totals = {"black": 0, "red": 0, "yellow": 0, "green": 0}

    for student in sorted(students_with_care, key=lambda s: (s.grade or 99, s.full_name)):
        care_reqs = set(student.care_requirements or [])
        if not care_reqs:
            continue

        # How many staff globally can cover ALL this student's requirements?
        global_qualified_ids = None
        for req in care_reqs:
            qualified_for_req = set(cert_staff_map.get(req, []))
            if global_qualified_ids is None:
                global_qualified_ids = qualified_for_req
            else:
                global_qualified_ids &= qualified_for_req

        global_qualified_ids = global_qualified_ids or set()

        days = []
        for weekday in range(5):
            sd = sd_map.get((str(student.id), weekday))

            # Student absent → skip (neutral)
            if sd and sd.absent_type == "full_day":
                days.append({"weekday": weekday, "risk": "none", "detail": "Frånvarande"})
                continue

            # Student not present this day (no care time)
            if not sd or (not sd.arrival_time and not sd.departure_time):
                days.append({"weekday": weekday, "risk": "none", "detail": "Ej schemalagd"})
                continue

            # Check: is there anyone globally who can cover?
            if len(global_qualified_ids) == 0:
                days.append({
                    "weekday": weekday,
                    "risk": "black",
                    "detail": f"Ingen personal har certifiering för {', '.join(care_reqs)}",
                })
                totals["black"] += 1
                continue

            # Check assigned FM/EM staff
            assigned_ids = set()
            if sd.fm_staff_id:
                assigned_ids.add(str(sd.fm_staff_id))
            if sd.em_staff_id:
                assigned_ids.add(str(sd.em_staff_id))

            # Are any assigned staff qualified?
            assigned_qualified = assigned_ids & global_qualified_ids

            if not assigned_ids or not assigned_qualified:
                # No qualified staff assigned
                # But are qualified staff working this day?
                day_available = day_staff.get(weekday, set())
                available_qualified = global_qualified_ids & day_available
                if available_qualified:
                    names = [staff_by_id[sid].full_name for sid in available_qualified if sid in staff_by_id]
                    days.append({
                        "weekday": weekday,
                        "risk": "red",
                        "detail": f"Ingen kvalificerad tilldelad. Tillgänglig: {', '.join(names[:3])}",
                    })
                else:
                    days.append({
                        "weekday": weekday,
                        "risk": "red",
                        "detail": "Ingen kvalificerad personal tilldelad eller tillgänglig denna dag",
                    })
                totals["red"] += 1
                continue

            # Staff is assigned and qualified — check SPOF
            # How many qualified staff are working this day?
            day_available = day_staff.get(weekday, set())
            available_qualified = global_qualified_ids & day_available

            if len(available_qualified) <= 1:
                name = next(
                    (staff_by_id[sid].full_name for sid in assigned_qualified if sid in staff_by_id),
                    "Okänd",
                )
                days.append({
                    "weekday": weekday,
                    "risk": "yellow",
                    "detail": f"Bara {name} kan täcka. Sårbart vid frånvaro.",
                })
                totals["yellow"] += 1
            else:
                days.append({
                    "weekday": weekday,
                    "risk": "green",
                    "detail": f"{len(available_qualified)} kvalificerade tillgängliga",
                })
                totals["green"] += 1

        rows.append({
            "student_id": str(student.id),
            "student_name": student.full_name,
            "grade": student.grade,
            "class_name": None,  # filled below
            "care_requirements": list(care_reqs),
            "days": days,
        })

    # Fill class names
    from app.models import SchoolClass
    classes = {str(c.id): c.name for c in db.query(SchoolClass).all()}
    for row in rows:
        sid = row["student_id"]
        student = next((s for s in students_with_care if str(s.id) == sid), None)
        if student and student.class_id:
            row["class_name"] = classes.get(str(student.class_id))

    return {
        "students": rows,
        "summary": totals,
    }
